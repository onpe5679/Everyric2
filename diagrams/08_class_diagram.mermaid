%%{init: {'theme': 'base'}}%%
classDiagram
    %% ===== Alignment Engines =====
    class BaseAlignmentEngine {
        <<abstract>>
        +config: AlignmentSettings
        +align(audio, lyrics, language) list~SyncResult~
        +transcribe(audio, language) TranscriptionResult
        +is_available() bool
        +get_transcription_sets() list
        +get_engine_type() str
    }

    class CTCEngine {
        -_model: Wav2Vec2ForCTC
        -_processor: Wav2Vec2Processor
        -_current_lang: str
        +align(audio, lyrics, language)
        -_align_cjk(waveform, lyrics, language)
        -_align_mms(waveform, lyrics, language)
    }

    class LyricsMatcher {
        +last_match_stats: MatchStats
        +match_lyrics_to_words(lyrics, words, lang)
    }

    BaseAlignmentEngine <|-- CTCEngine
    CTCEngine --> LyricsMatcher

    %% ===== Project File (NEW) =====
    class ProjectFile {
        +path: Path
        +data: AlignmentData
        +save(data) Path
        +load() AlignmentData
        +from_sync_results(results, path, meta, trans)$ ProjectFile
        +get_line_results() list~SyncResult~
        +apply_translations(results) list~SyncResult~
        +get_translation_track() list~SyncResult~
    }

    class AlignmentData {
        +metadata: ProjectMetadata
        +results: list~SyncResult~
        +translations: list~TranslationData~
        +to_dict() dict
        +from_dict(data)$ AlignmentData
    }

    class ProjectMetadata {
        +version: str
        +created_at: str
        +source_audio: str
        +source_lyrics: str
        +language: str
        +engine: str
    }

    class TranslationData {
        +line_index: int
        +original: str
        +translation: str
        +pronunciation: str
    }

    ProjectFile --> AlignmentData
    AlignmentData --> ProjectMetadata
    AlignmentData --> TranslationData

    %% ===== Tokenizer (NEW) =====
    class Tokenizer {
        +language: str
        +use_mecab: bool
        +tokenize(text) list~TokenInfo~
        +split_into_words(text) list~str~
        +split_into_characters(text) list~str~
        -_tokenize_japanese(text)
        -_tokenize_japanese_mecab(text)
        -_tokenize_chinese(text)
        -_tokenize_korean(text)
    }

    class TokenInfo {
        +surface: str
        +pos: str
        +reading: str
        +is_content_word: bool
    }

    Tokenizer --> TokenInfo

    %% ===== Post-Processing =====
    class SilenceHandler {
        +settings: SegmentationSettings
        +detected_interludes: list~InterludeInfo~
        +process(results) list~SyncResult~
        +detect_silence_gaps(results) list~dict~
        +get_interludes() list~InterludeInfo~
    }

    class InterludeInfo {
        +start: float
        +end: float
        +duration: float
        +after_line: int
    }

    class SegmentationProcessor {
        +settings: SegmentationSettings
        +language: str
        +tokenizer: Tokenizer
        +process(results, language) list~SyncResult~
        -_process_line_mode(results)
        -_process_word_mode(results)
        -_process_character_mode(results)
        -_split_text_to_words(result)
    }

    class SegmentationSettings {
        +mode: line/word/character
        +min_silence_gap: float
        +interlude_gap: float
        +max_chars_per_segment: int
        +use_mecab: bool
    }

    SilenceHandler --> SegmentationSettings
    SilenceHandler --> InterludeInfo
    SegmentationProcessor --> SegmentationSettings
    SegmentationProcessor --> Tokenizer

    %% ===== Output =====
    class MultiOutputGenerator {
        +format_type: str
        +segment_mode: str
        +generate_all_variants(results, trans, dir, name, line_results)
        -_generate_separated_tracks(results, trans, dir, name, line_results)
        -_generate_original(results, dir, name)
        -_generate_translated(results, dir, name)
    }

    class OutputFile {
        +variant: str
        +path: Path
        +content: str
    }

    MultiOutputGenerator --> OutputFile

    %% ===== Translation =====
    class BaseTranslator {
        <<abstract>>
        +settings: TranslationSettings
        +translate(lyrics, source, target) TranslationResult
    }

    class GeminiTranslator {
        -api_key: str
        +translate(lyrics, source, target)
    }

    class OpenAICompatibleTranslator {
        -api_key: str
        -api_url: str
        +translate(lyrics, source, target)
    }

    BaseTranslator <|-- GeminiTranslator
    BaseTranslator <|-- OpenAICompatibleTranslator

    %% ===== Data Classes =====
    class SyncResult {
        +text: str
        +start_time: float
        +end_time: float
        +confidence: float
        +line_number: int
        +word_segments: list~WordSegment~
        +translation: str
        +pronunciation: str
    }

    class WordSegment {
        +word: str
        +start: float
        +end: float
        +confidence: float
    }

    SyncResult --> WordSegment
    AlignmentData --> SyncResult
    SilenceHandler --> SyncResult
    SegmentationProcessor --> SyncResult

    %% Notes
    note for ProjectFile "프로젝트 파일\n- 모든 정렬 데이터 보존\n- reprocess용 루트 데이터"
    note for Tokenizer "언어별 토크나이저\n- ja: MeCab/fugashi\n- zh: jieba\n- ko: konlpy"
    note for SilenceHandler "간주 감지 (interlude_gap)\n+ 짧은 무성구간 병합"
    note for MultiOutputGenerator "분할 모드별 출력\n- line: 통합 자막\n- word/char: 트랙 분리"
